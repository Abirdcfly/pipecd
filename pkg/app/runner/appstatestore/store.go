// Copyright 2020 The PipeCD Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appstatestore

import (
	"sync"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

const (
	appIDAnnotationKey              = "pipecd.dev/app-id"
	commitAnnotationKey             = "pipecd.dev/commit"
	originalAPIVersionAnnotationKey = "pipecd.dev/original-api-version"
)

type store struct {
	apps map[string]*appLiveNodes
	// The map with the key is "resource's uid" and the value is "appResource".
	// Because the depended resource does not include the appID in its annotations
	// so this is used to determine the application of a depended resource.
	resources map[string]appResource
	mu        sync.RWMutex
}

type appLiveNodes struct {
	appID         string
	managingNodes map[string]*node
	dependedNodes map[string]*node
	updatedAt     time.Time
}

type node struct {
	// The unique identifier of the resource generated by Kubernetes.
	uid string
	// The unique idenfitifer of the application this node belongs to.
	appID string
	// The resourceKey of the first added resource into this node.
	firstResourceKey resourceKey
	// The key to the resource that matching with the originalAPIVersion.
	// This will only be set for managing resources.
	matchResourceKey resourceKey
	// The map of resources that have a same uid.
	// This always has at least one resource.
	resources map[resourceKey]*unstructured.Unstructured
}

type appResource struct {
	appID    string
	owners   []metav1.OwnerReference
	resource *unstructured.Unstructured
}

func (s *store) initialize() {
	s.mu.Lock()
	defer s.mu.Unlock()

	// Try to determine the application ID of all resources.
	for uid, an := range s.resources {
		// Resource has already assigned into an application.
		if an.appID != "" {
			continue
		}
		appID := s.findAppIDByOwners(an.owners)
		if appID == "" {
			continue
		}

		// Add the missing resource into the dependedResources of the app.
		key := makeResourceKey(an.resource)
		s.apps[appID].addDependedResource(uid, key, an.resource)

		an.appID = appID
		s.resources[uid] = an
	}

	// Remove all resources which do not have appID.
	for uid, an := range s.resources {
		if an.appID == "" {
			delete(s.resources, uid)
		}
	}
}

func (s *store) findAppIDByOwners(owners []metav1.OwnerReference) string {
	for _, ref := range owners {
		owner, ok := s.resources[string(ref.UID)]
		// Owner does not present in the resources.
		if !ok {
			continue
		}
		// The owner is containing the appID.
		if owner.appID != "" {
			return owner.appID
		}
		// Try with the owners of the owner.
		if appID := s.findAppIDByOwners(owner.owners); appID != "" {
			return appID
		}
	}
	return ""
}

func (s *store) onAddResource(obj *unstructured.Unstructured) {
	var (
		uid    = string(obj.GetUID())
		appID  = obj.GetAnnotations()[appIDAnnotationKey]
		key    = makeResourceKey(obj)
		owners = obj.GetOwnerReferences()
	)

	// If this is a resource managed by PipeCD
	// it must contain appID in its annotations and has no owners.
	if appID != "" && len(owners) == 0 {
		s.mu.Lock()
		defer s.mu.Unlock()

		// When this obj is for a new application
		// we register a new application to the apps.
		if _, ok := s.apps[appID]; !ok {
			s.apps[appID] = &appLiveNodes{
				appID:         appID,
				managingNodes: make(map[string]*node),
				dependedNodes: make(map[string]*node),
				updatedAt:     time.Now(),
			}
		}

		// Append the resource to the application's managingNodes.
		s.apps[appID].addManagingResource(uid, key, obj)

		// And update the resources.
		s.resources[uid] = appResource{appID: appID, owners: owners, resource: obj}
		return
	}

	// Try to determine the application ID by traveling its owners.
	s.mu.RLock()
	appID = s.findAppIDByOwners(owners)
	s.mu.RUnlock()

	s.mu.Lock()
	defer s.mu.Unlock()

	// Append the resource to the application's dependedNodes.
	if appID != "" {
		s.apps[appID].addDependedResource(uid, key, obj)
	}

	// And update the resources.
	s.resources[uid] = appResource{appID: appID, owners: owners, resource: obj}
}

func (s *store) onUpdateResource(oldObj, obj *unstructured.Unstructured) {
	s.onAddResource(obj)
}

func (s *store) onDeleteResource(obj *unstructured.Unstructured) {
	var (
		uid    = string(obj.GetUID())
		appID  = obj.GetAnnotations()[appIDAnnotationKey]
		key    = makeResourceKey(obj)
		owners = obj.GetOwnerReferences()
	)

	// If this is a resource managed by PipeCD
	// it must contain appID in its annotations and has no owners.
	if appID != "" && len(owners) == 0 {
		s.mu.Lock()
		defer s.mu.Unlock()

		delete(s.resources, uid)
		if app, ok := s.apps[appID]; ok {
			app.deleteManagingResource(uid, key)
		}
		return
	}

	// Try to determine the application ID by traveling its owners.
	s.mu.RLock()
	appID = s.findAppIDByOwners(owners)
	s.mu.RUnlock()

	s.mu.Lock()
	defer s.mu.Unlock()

	// Delete the resource to the application's dependedNodes.
	if app, ok := s.apps[appID]; ok {
		app.deleteDependedResource(uid, key)
	}
	delete(s.resources, uid)
}

func (s *store) getManagingNodesForApp(appID string) map[string]*node {
	s.mu.RLock()
	defer s.mu.RUnlock()
	app, ok := s.apps[appID]
	if !ok {
		return nil
	}
	return app.managingNodes
}

func (s *store) getDependedNodesForApp(appID string) map[string]*node {
	s.mu.RLock()
	defer s.mu.RUnlock()
	app, ok := s.apps[appID]
	if !ok {
		return nil
	}
	return app.dependedNodes
}

func (a *appLiveNodes) addManagingResource(uid string, key resourceKey, obj *unstructured.Unstructured) {
	originalAPIVersion := obj.GetAnnotations()[originalAPIVersionAnnotationKey]

	if cur, ok := a.managingNodes[uid]; ok {
		cur.resources[key] = obj
		if originalAPIVersion == key.APIVersion {
			cur.matchResourceKey = key
		}
		a.updatedAt = time.Now()
		return
	}

	n := &node{
		uid:              uid,
		appID:            a.appID,
		firstResourceKey: key,
		resources:        map[resourceKey]*unstructured.Unstructured{key: obj},
	}
	if originalAPIVersion == key.APIVersion {
		n.matchResourceKey = key
	}
	a.managingNodes[uid] = n
	a.updatedAt = time.Now()
}

func (a *appLiveNodes) deleteManagingResource(uid string, key resourceKey) {
	n, ok := a.managingNodes[uid]
	if !ok {
		return
	}
	delete(n.resources, key)
	if len(n.resources) == 0 {
		delete(a.managingNodes, uid)
	}
	a.updatedAt = time.Now()
}

func (a *appLiveNodes) addDependedResource(uid string, key resourceKey, obj *unstructured.Unstructured) {
	if cur, ok := a.dependedNodes[uid]; ok {
		cur.resources[key] = obj
		a.updatedAt = time.Now()
		return
	}
	a.dependedNodes[uid] = &node{
		uid:              uid,
		appID:            a.appID,
		firstResourceKey: key,
		resources:        map[resourceKey]*unstructured.Unstructured{key: obj},
	}
	a.updatedAt = time.Now()
}

func (a *appLiveNodes) deleteDependedResource(uid string, key resourceKey) {
	n, ok := a.dependedNodes[uid]
	if !ok {
		return
	}
	delete(n.resources, key)
	if len(n.resources) == 0 {
		delete(a.dependedNodes, uid)
	}
	a.updatedAt = time.Now()
}
