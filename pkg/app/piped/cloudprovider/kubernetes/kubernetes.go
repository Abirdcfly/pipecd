// Copyright 2020 The PipeCD Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kubernetes

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"

	"go.uber.org/zap"

	"github.com/kapetaniosci/pipe/pkg/app/piped/toolregistry"
	"github.com/kapetaniosci/pipe/pkg/cache"
	"github.com/kapetaniosci/pipe/pkg/config"
)

const (
	LabelManagedBy          = "pipecd.dev/managed-by"           // Always be piped.
	LabelApplication        = "pipecd.dev/application"          // The application this resource belongs to.
	LabelVariant            = "pipecd.dev/variant"              // Variant name: primary, stage, baseline
	LabelCommitHash         = "pipecd.dev/commit-hash"          // Hash value of the deployed commit.
	LabelResourceKey        = "pipecd.dev/resource-key"         // The resource key generated by apiVersion, namespace and name. e.g. apps/v1/Deployment/namespace/demo-app
	LabelOriginalAPIVersion = "pipecd.dev/original-api-version" // The api version defined in git configuration. e.g. apps/v1
	ManagedByPiped          = "piped"

	kustomizationFileName = "kustomization.yaml"
)

type TemplatingMethod string

const (
	TemplatingMethodHelm      TemplatingMethod = "helm"
	TemplatingMethodKustomize TemplatingMethod = "kustomize"
	TemplatingMethodNone      TemplatingMethod = "none"
)

type Provider interface {
	ManifestLoader
	Applier

	Init(ctx context.Context) error
}

type ManifestLoader interface {
	LoadManifests(ctx context.Context, commitHash string) ([]Manifest, error)
}

type Applier interface {
	Apply(ctx context.Context, manifests []Manifest) error
	Delete(ctx context.Context, key ResourceKey) error
}

// Option defines a function to set configurable field of Provider.
type Option func(p *provider)

func WithLogger(logger *zap.Logger) Option {
	return func(p *provider) {
		p.logger = logger.Named("kubernetes-provider")
	}
}

func WithCache(c cache.Cache) Option {
	return func(p *provider) {
		p.appManifestsCache = &appManifestsCache{cache: c}
	}
}

type provider struct {
	appID   string
	appDir  string
	repoDir string
	input   config.KubernetesDeploymentInput

	appManifestsCache *appManifestsCache
	logger            *zap.Logger

	kubectl          *Kubectl
	kustomize        *Kustomize
	helm             *Helm
	templatingMethod TemplatingMethod
}

func NewProvider(appID, appDir, repoDir string, input config.KubernetesDeploymentInput, opts ...Option) Provider {
	p := &provider{
		appID:   appID,
		appDir:  appDir,
		repoDir: repoDir,
		input:   input,
		logger:  zap.NewNop(),
	}
	for _, opt := range opts {
		opt(p)
	}

	return p
}

func (p *provider) Init(ctx context.Context) (err error) {
	p.templatingMethod = determineTemplatingMethod(p.input, p.appDir)

	switch p.templatingMethod {
	case TemplatingMethodHelm:
		p.helm, err = p.findHelm(ctx, p.input.HelmVersion)

	case TemplatingMethodKustomize:
		p.kustomize, err = p.findKustomize(ctx, p.input.KustomizeVersion)

	case TemplatingMethodNone:
		p.kubectl, err = p.findKubectl(ctx, p.input.KubectlVersion)

	default:
		err = fmt.Errorf("unsupport templating method %v", p.templatingMethod)
	}
	return
}

func (p *provider) LoadManifests(ctx context.Context, commitHash string) (manifests []Manifest, err error) {
	if p.appManifestsCache != nil {
		manifests, err = p.appManifestsCache.Get(p.appID, commitHash)
		if err == nil {
			return
		}
		if errors.Is(err, cache.ErrNotFound) {
			p.logger.Info("app manifests was not found in cache",
				zap.String("app-id", p.appID),
				zap.String("commit-hash", commitHash),
			)
		} else {
			p.logger.Error("failed to get app manifests from cache",
				zap.String("app-id", p.appID),
				zap.String("commit-hash", commitHash),
				zap.Error(err),
			)
		}
	}

	defer func() {
		if p.appManifestsCache == nil {
			return
		}
		if err != nil || len(manifests) == 0 {
			return
		}
		if err := p.appManifestsCache.Put(p.appID, commitHash, manifests); err != nil {
			p.logger.Error("failed to put app manifests to cache",
				zap.String("app-id", p.appID),
				zap.String("commit-hash", commitHash),
				zap.Error(err),
			)
		}
	}()

	switch p.templatingMethod {
	case TemplatingMethodHelm:
		return nil, nil

	case TemplatingMethodKustomize:
		return nil, nil

	case TemplatingMethodNone:
		manifests, err = LoadPlainYAMLMannifests(ctx, p.appDir, p.input.Manifests)

	default:
		err = fmt.Errorf("unsupport templating method %v", p.templatingMethod)
	}
	return
}

func (p *provider) Apply(ctx context.Context, manifests []Manifest) (err error) {
	switch p.templatingMethod {
	case TemplatingMethodHelm:
		return nil

	case TemplatingMethodKustomize:
		return nil

	case TemplatingMethodNone:
		err = p.kubectl.Apply(ctx, manifests)

	default:
		err = fmt.Errorf("unsupport templating method %v", p.templatingMethod)
	}
	return
}

func (p *provider) Delete(ctx context.Context, k ResourceKey) (err error) {
	switch p.templatingMethod {
	case TemplatingMethodHelm:
		return nil

	case TemplatingMethodKustomize:
		return nil

	case TemplatingMethodNone:
		err = p.kubectl.Delete(ctx, k)

	default:
		err = fmt.Errorf("unsupport templating method %v", p.templatingMethod)
	}
	return
}

func (p *provider) findKubectl(ctx context.Context, version string) (*Kubectl, error) {
	path, installed, err := toolregistry.DefaultRegistry().Kubectl(ctx, version)
	if err != nil {
		return nil, fmt.Errorf("no kubectl %s (%v)", version, err)
	}
	if installed {
		p.logger.Info(fmt.Sprintf("kubectl %s has just been installed because of no pre-installed binary for that version", version))
	}
	return NewKubectl(path), nil
}

func (p *provider) findKustomize(ctx context.Context, version string) (*Kustomize, error) {
	path, installed, err := toolregistry.DefaultRegistry().Kustomize(ctx, version)
	if err != nil {
		return nil, fmt.Errorf("no kustomize %s (%v)", version, err)
	}
	if installed {
		p.logger.Info(fmt.Sprintf("kustomize %s has just been installed because of no pre-installed binary for that version", version))
	}
	return NewKustomize(path), nil
}

func (p *provider) findHelm(ctx context.Context, version string) (*Helm, error) {
	path, installed, err := toolregistry.DefaultRegistry().Helm(ctx, version)
	if err != nil {
		return nil, fmt.Errorf("no helm %s (%v)", version, err)
	}
	if installed {
		p.logger.Info(fmt.Sprintf("helm %s has just been installed because of no pre-installed binary for that version", version))
	}
	return NewHelm(path), nil
}

func determineTemplatingMethod(input config.KubernetesDeploymentInput, appDirPath string) TemplatingMethod {
	if input.HelmChart != nil {
		return TemplatingMethodHelm
	}
	if len(input.HelmValueFiles) > 0 {
		return TemplatingMethodHelm
	}
	if input.HelmVersion != "" {
		return TemplatingMethodHelm
	}
	if _, err := os.Stat(filepath.Join(appDirPath, kustomizationFileName)); err == nil {
		return TemplatingMethodKustomize
	}
	return TemplatingMethodNone
}
